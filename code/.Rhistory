return("type your written answer here")
}
# Challenge question G should be written in a separate file that has no dependencies on any functions here.
Challenge_A()
direction = pi
direction
?sin
?sinpi
direction = pi / 4
length = 1
# ?sin
sin(direction)
direction = pi / 4
length = 1
# ?sin
sinpi(direction)
2^0.5
1/(2^0.5)
?plot()
start_position = c(0,0)
direction = pi / 4
length = 1
end_position = c(0,0)
end_position[1] = start_position[1] + length * cos(direction)
end_position[2] = start_position[2] + length * sin(direction)
x_position = data.frame(c(start_position[1],end_position[1]),c(start_position[2],end_position[2]))
start_position = c(0,0)
direction = pi / 4
length = 1
end_position = c(0,0)
end_position[1] = start_position[1] + length * cos(direction)
end_position[2] = start_position[2] + length * sin(direction)
line_position = data.frame(c(start_position[1],end_position[1]),c(start_position[2],end_position[2]))
names(line_position) = c("start","end")
start_position = c(0,0)
direction = pi / 4
length = 1
end_position = c(0,0)
end_position[1] = start_position[1] + length * cos(direction)
end_position[2] = start_position[2] + length * sin(direction)
line_position = data.frame(c(start_position[1],end_position[1]),c(start_position[2],end_position[2]))
names(line_position) = c("x_axis","y_axis")
ggplot() +geom_line(data = line_position, aes(x = x_axis, y = y_axis))
end_position_1 = turtle(start_position,direction,length)
direction_2 = direction + pi / 4
if(direction_2 >= 2 * pi){
direction_2 = direction_2 - 2 * pi
}
length_2 = length *0.95
end_position_2 = turtle(end_position_1,direction_2,length)
end_position_1 = turtle(start_position,direction,length)
direction_2 = direction + pi / 4
if(direction_2 >= 2 * pi){
direction_2 = direction_2 - 2 * pi
}
length_2 = length *0.95
end_position_2 = turtle(end_position_1,direction_2,length)
start_position = c(0,0)
direction = pi / 4
length = 1
end_position = c(0,0)
end_position[1] = start_position[1] + length * cos(direction)
end_position[2] = start_position[2] + length * sin(direction)
# line_position = data.frame(c(start_position[1],end_position[1]),c(start_position[2],end_position[2]))
# names(line_position) = c("x_axis","y_axis")
# ggplot() +geom_line(data = line_position, aes(x = x_axis, y = y_axis))
plot()
lines(start_position, end_position, type='l')
plot(x= line_position$x_axis, y = line_position$y_axis)
lines(start_position, end_position, type='l')
plot(x= line_position$x_axis, y = line_position$y_axis)
lines(start_position, end_position, type='l')
return(end_position) # you should return your endpoint here.
?lines()
plot(x= line_position$x_axis, y = line_position$y_axis)
lines(start_position, end_position, type='l')
lines(x = start_position, y = end_position, type='l')
plot(x= line_position$x_axis, y = line_position$y_axis)
lines(x = line_position$x_axis, y = line_position$y_axis, type='l')
end_position_1 = turtle(start_position,direction,length)
direction_2 = direction + pi / 4
if(direction_2 >= 2 * pi){
direction_2 = direction_2 - 2 * pi
}
length_2 = length *0.95
end_position_2 = turtle(end_position_1,direction_2,length)
end_position_1 = turtle(start_position,direction,length)
direction_2 = direction + pi / 4
if(direction_2 >= 2 * pi){
direction_2 = direction_2 - 2 * pi
}
length_2 = length *0.95
end_position_2 = spiral(end_position_1,direction_2,length)
rm(list = ls())
load("../data/KeyWestAnnualMeanTemperature.RData")
plot(ats)
firstYear <- c()
secondYear <- c()
for(i in 1:(length(ats$Year)-1)){
firstYear <- append(firstYear,ats$Temp[i])
secondYear <- append(secondYear,ats$Temp[i+1])
}
correlationCoff <- cor(firstYear,secondYear)
tempVect <- ats$Temp
correlationCoffVector <- c()
for (i in 1:10000){
tempVect <- sample(tempVect,length(ats$Year), replace = FALSE)
firstYear <- c()
secondYear <- c()
for(j in 1:(length(tempVect)-1)){
firstYear <- append(firstYear,tempVect[j])
secondYear <- append(secondYear,tempVect[j+1])
}
correlationCoffVector <- append(correlationCoffVector,cor(firstYear,secondYear))
}
correlationCoffBoolean <- correlationCoffVector[correlationCoffVector>correlationCoff]
fractionCorrCoff <- length(correlationCoffBoolean) / 10000
print (fractionCorrCoff)
# A simple script to illustrate R input-output.
# Run line by line and check inputs outputs to understand what is happening
MyData <- read.csv("../data/trees.csv", header = TRUE) # import with headers
write.csv(MyData, "../results/MyData.csv") #write it out as a new file
write.table(MyData[1,], file = "../results/MyData.csv",append=TRUE) # Append to it
write.csv(MyData, "../results/MyData.csv", row.names=TRUE) # write row names
write.table(MyData, "../results/MyData.csv", col.names=FALSE) # ignore column names
library(ggplot2)
build_ellipse <- function(hradius, vradius){ # function that returns an ellipse
npoints = 250
a <- seq(0, 2 * pi, length = npoints + 1)
x <- hradius * cos(a)
y <- vradius * sin(a)
return(data.frame(x = x, y = y))
}
N <- 250 # Assign size of the matrix
M <- matrix(rnorm(N * N), N, N) # Build the matrix
eigvals <- eigen(M)$values # Find the eigenvalues
eigDF <- data.frame("Real" = Re(eigvals), "Imaginary" = Im(eigvals)) # Build a dataframe
my_radius <- sqrt(N) # The radius of the circle is sqrt(N)
ellDF <- build_ellipse(my_radius, my_radius) # Dataframe to plot the ellipse
names(ellDF) <- c("Real", "Imaginary") # rename the columns
# plot the eigenvalues
p <- ggplot(eigDF, aes(x = Real, y = Imaginary))
p <- p +
geom_point(shape = I(3)) +
theme(legend.position = "none")
# now add the vertical and horizontal line
p <- p + geom_hline(aes(yintercept = 0))
p <- p + geom_vline(aes(xintercept = 0))
# finally, add the ellipse
p <- p + geom_polygon(data = ellDF, aes(x = Real, y = Imaginary, alpha = 1/20, fill =
"red"))
pdf("../results/Girko.pdf")
print(p)
dev.off()
############# Clean the environment ###############
rm(list = ls())
require(ggplot2)
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")
pdf("../results/PP_Regress.pdf")
ggplot(MyDF, aes(y = (Predator.mass), x = (Prey.mass), shape= I(3),
colour = Predator.lifestage)) + geom_point() +
facet_grid(Type.of.feeding.interaction~.) +
geom_smooth(formula = y ~ x,method = "lm",fullrange=TRUE)+
scale_x_log10() +
scale_y_log10() +
xlab("Prey Mass in grams") +
ylab("Predator Mass in grams") +
theme_bw() +
theme(legend.position="bottom") +
coord_fixed(ratio = 0.4)
graphics.off();
ToFI <- unique(MyDF$Type.of.feeding.interaction)
LS <- unique(MyDF$Predator.lifestage)
summary_regression = data.frame()
for(i in ToFI){
for(j in LS){
MyDF_subset <- subset(MyDF,MyDF$Type.of.feeding.interaction == i)
MyDF_subset <- subset(MyDF,MyDF$Predator.lifestage == j)
regression_result = lm(formula = Predator.mass ~ Prey.mass, data = MyDF_subset)
f <- summary(regression_result)$fstatistic
p <- pf(f[1],f[2],f[3],lower.tail=F)
attributes(p) <- NULL
new_row <- c(i,j, as.numeric(regression_result$coefficient[1]),as.numeric(regression_result$coefficient[2]),
as.numeric(summary(regression_result)$r.squared),
f[1],f[2],f[3],
as.numeric(p)
)
summary_regression <- rbind(summary_regression, new_row,stringsAsFactors = FALSE)
}
}
names(summary_regression) <- c("Type_of_feeding_interaction","Predator_lifestage",
"Intercept", "Prey.mass","R.square",
"F_statistic_value","F_statistic_numdf","F_statistic_dendf","P_value")
write.csv(summary_regression,"../results/PP_Regress_Results.csv")
############# Clean the environment ###############
rm(list = ls())
require(ggplot2)
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")
pdf("../results/PP_Regress.pdf")
ggplot(MyDF, aes(y = (Predator.mass), x = (Prey.mass), shape= I(3),
colour = Predator.lifestage)) + geom_point() +
facet_grid(Type.of.feeding.interaction~.) +
geom_smooth(formula = y ~ x,method = "lm",fullrange=TRUE)+
scale_x_log10() +
scale_y_log10() +
xlab("Prey Mass in grams") +
ylab("Predator Mass in grams") +
theme_bw() +
theme(legend.position="bottom") +
coord_fixed(ratio = 0.4)
graphics.off();
ToFI <- unique(MyDF$Type.of.feeding.interaction)
LS <- unique(MyDF$Predator.lifestage)
summary_regression = data.frame()
for(i in ToFI){
for(j in LS){
MyDF_subset <- subset(MyDF,MyDF$Type.of.feeding.interaction == i)
MyDF_subset <- subset(MyDF,MyDF$Predator.lifestage == j)
regression_result = lm(formula = Predator.mass ~ Prey.mass, data = MyDF_subset)
f <- summary(regression_result)$fstatistic
p <- pf(f[1],f[2],f[3],lower.tail=F)
attributes(p) <- NULL
new_row <- c(i,j, as.numeric(regression_result$coefficient[1]),as.numeric(regression_result$coefficient[2]),
as.numeric(summary(regression_result)$r.squared),
f[1],f[2],f[3],
as.numeric(p)
)
summary_regression <- rbind(summary_regression, new_row,stringsAsFactors = FALSE)
}
}
names(summary_regression) <- c("Type_of_feeding_interaction","Predator_lifestage",
"Intercept", "Prey.mass","R.square",
"F_statistic_value","F_statistic_numdf","F_statistic_dendf","P_value")
write.csv(summary_regression,"../results/PP_Regress_Results.csv")
############# Clean the environment ###############
rm(list = ls())
require(ggplot2)
MyDF <- read.csv("../data/EcolArchives-E089-51-D1.csv")
pdf("../results/PP_Regress.pdf")
ggplot(MyDF, aes(y = (Predator.mass), x = (Prey.mass), shape= I(3),
colour = Predator.lifestage)) + geom_point() +
facet_grid(Type.of.feeding.interaction~.) +
geom_smooth(formula = y ~ x,method = "lm",fullrange=TRUE)+
scale_x_log10() +
scale_y_log10() +
xlab("Prey Mass in grams") +
ylab("Predator Mass in grams") +
theme_bw() +
theme(legend.position="bottom") +
coord_fixed(ratio = 0.4)
# graphics.off();
ToFI <- unique(MyDF$Type.of.feeding.interaction)
LS <- unique(MyDF$Predator.lifestage)
summary_regression = data.frame()
for(i in ToFI){
for(j in LS){
MyDF_subset <- subset(MyDF,MyDF$Type.of.feeding.interaction == i)
MyDF_subset <- subset(MyDF,MyDF$Predator.lifestage == j)
regression_result = lm(formula = Predator.mass ~ Prey.mass, data = MyDF_subset)
f <- summary(regression_result)$fstatistic
p <- pf(f[1],f[2],f[3],lower.tail=F)
attributes(p) <- NULL
new_row <- c(i,j, as.numeric(regression_result$coefficient[1]),as.numeric(regression_result$coefficient[2]),
as.numeric(summary(regression_result)$r.squared),
f[1],f[2],f[3],
as.numeric(p)
)
summary_regression <- rbind(summary_regression, new_row,stringsAsFactors = FALSE)
}
}
names(summary_regression) <- c("Type_of_feeding_interaction","Predator_lifestage",
"Intercept", "Prey.mass","R.square",
"F_statistic_value","F_statistic_numdf","F_statistic_dendf","P_value")
write.csv(summary_regression,"../results/PP_Regress_Results.csv")
#install the sqlite package
install.packages('sqldf')
# To load the packages
library(sqldf)
# The command below opens a connection to the database.
#If the database does not yet exist, one is created in the working directory of R.
db <- dbConnect(SQLite(), dbname='Test.sqlite')
# Now let's enter some data to the table
# Using the db connection to our database, the data are entered using SQL queries
# The next command just create the table
dbSendQuery(conn = db,
"CREATE TABLE Consumer
(OriginalID TEXT,
ConKingdom TEXT,
ConPhylum TEXT,
ConSpecies TEXT)")
# Once the table is created, we can enter the data.
#INSERT specifies where the data is entered (here the School table).
#VALUES contains the data
dbSendQuery(conn = db,
"INSERT INTO Consumer
VALUES (1, 'Animalia', 'Arthropoda', 'Chaoborus trivittatus')")
dbSendQuery(conn = db,
"INSERT INTO Consumer
VALUES (2, 'Animalia', 'Arthropoda', 'Chaoborus americanus')")
dbSendQuery(conn = db,
"INSERT INTO Consumer
VALUES (3, 'Animalia', 'Chordata', 'Stizostedion vitreum')")
# Once we have our table, we can query the results using:
dbGetQuery(db, "SELECT * FROM Consumer")
dbGetQuery(db, "SELECT * FROM Consumer WHERE ConPhylum='Chordata'")
# Tables can be also imported from csv files.
# As example, let's use the Biotraits dataset.
# The easiest way is to read the csv files into R as data frames.
# Then the data frames are imported into the database.
Resource <- read.csv("../Data/Resource.csv")  # Read csv files into R
# Import data frames into database
dbWriteTable(conn = db, name = "Resource", value = Resource, row.names = FALSE)
# Check that the data have been correctly imported into the School table.
dbListTables(db)                 # The tables in the database
dbListFields(db,"Resource")       # The columns in a table
dbReadTable(db, "Resource")    # The data in a table
# Before leaving RSQLite, there is a bit of tidying-up to do.
# The connection to the database is closed, and as precaution
# the three data frames are removed from R’s environment.
dbDisconnect(db)            # Close connection
rm(list = c("Resource"))   # Remove data frames
#install the sqlite package
# install.packages('sqldf')
# To load the packages
library(sqldf)
# The command below opens a connection to the database.
#If the database does not yet exist, one is created in the working directory of R.
db <- dbConnect(SQLite(), dbname='Test.sqlite')
# Now let's enter some data to the table
# Using the db connection to our database, the data are entered using SQL queries
# The next command just create the table
dbSendQuery(conn = db,
"CREATE TABLE Consumer
(OriginalID TEXT,
ConKingdom TEXT,
ConPhylum TEXT,
ConSpecies TEXT)")
# Once the table is created, we can enter the data.
#INSERT specifies where the data is entered (here the School table).
#VALUES contains the data
dbSendQuery(conn = db,
"INSERT INTO Consumer
VALUES (1, 'Animalia', 'Arthropoda', 'Chaoborus trivittatus')")
dbSendQuery(conn = db,
"INSERT INTO Consumer
VALUES (2, 'Animalia', 'Arthropoda', 'Chaoborus americanus')")
dbSendQuery(conn = db,
"INSERT INTO Consumer
VALUES (3, 'Animalia', 'Chordata', 'Stizostedion vitreum')")
# Once we have our table, we can query the results using:
dbGetQuery(db, "SELECT * FROM Consumer")
dbGetQuery(db, "SELECT * FROM Consumer WHERE ConPhylum='Chordata'")
# Tables can be also imported from csv files.
# As example, let's use the Biotraits dataset.
# The easiest way is to read the csv files into R as data frames.
# Then the data frames are imported into the database.
Resource <- read.csv("../Data/Resource.csv")  # Read csv files into R
# Import data frames into database
dbWriteTable(conn = db, name = "Resource", value = Resource, row.names = FALSE)
# Check that the data have been correctly imported into the School table.
dbListTables(db)                 # The tables in the database
dbListFields(db,"Resource")       # The columns in a table
dbReadTable(db, "Resource")    # The data in a table
# Before leaving RSQLite, there is a bit of tidying-up to do.
# The connection to the database is closed, and as precaution
# the three data frames are removed from R’s environment.
dbDisconnect(db)            # Close connection
rm(list = c("Resource"))   # Remove data frames
#install the sqlite package
# install.packages('sqldf')
# To load the packages
library(sqldf)
# The command below opens a connection to the database.
#If the database does not yet exist, one is created in the working directory of R.
db <- dbConnect(SQLite(), dbname='Test.sqlite')
# Now let's enter some data to the table
# Using the db connection to our database, the data are entered using SQL queries
# The next command just create the table
dbSendQuery(conn = db,
"CREATE TABLE Consumer
(OriginalID TEXT,
ConKingdom TEXT,
ConPhylum TEXT,
ConSpecies TEXT)")
# Once the table is created, we can enter the data.
#INSERT specifies where the data is entered (here the School table).
#VALUES contains the data
dbSendQuery(conn = db,
"INSERT INTO Consumer
VALUES (1, 'Animalia', 'Arthropoda', 'Chaoborus trivittatus')")
dbSendQuery(conn = db,
"INSERT INTO Consumer
VALUES (2, 'Animalia', 'Arthropoda', 'Chaoborus americanus')")
dbSendQuery(conn = db,
"INSERT INTO Consumer
VALUES (3, 'Animalia', 'Chordata', 'Stizostedion vitreum')")
# Once we have our table, we can query the results using:
dbGetQuery(db, "SELECT * FROM Consumer")
dbGetQuery(db, "SELECT * FROM Consumer WHERE ConPhylum='Chordata'")
# Tables can be also imported from csv files.
# As example, let's use the Biotraits dataset.
# The easiest way is to read the csv files into R as data frames.
# Then the data frames are imported into the database.
Resource <- read.csv("../Data/Resource.csv")  # Read csv files into R
# Import data frames into database
dbWriteTable(conn = db, name = "Resource", value = Resource, row.names = FALSE)
# Check that the data have been correctly imported into the School table.
dbListTables(db)                 # The tables in the database
dbListFields(db,"Resource")       # The columns in a table
dbReadTable(db, "Resource")    # The data in a table
# Before leaving RSQLite, there is a bit of tidying-up to do.
# The connection to the database is closed, and as precaution
# the three data frames are removed from R’s environment.
dbDisconnect(db)            # Close connection
rm(list = c("Resource"))   # Remove data frames
# Language: R
# Script: SQLinR.R
# Des: r for database
# Usage: Rscript SQLinR.R
# Date: Oct, 2021
#install the sqlite package
#install.packages('sqldf')
# To load the packages
library(sqldf)
# The command below opens a connection to the database.
#If the database does not yet exist, one is created in the working directory of R.
db <- dbConnect(SQLite(), dbname='Test.sqlite')
# Now let's enter some data to the table
# Using the db connection to our database, the data are entered using SQL queries
# The next command just create the table
dbSendQuery(conn = db,
"CREATE TABLE Consumer
(OriginalID TEXT,
ConKingdom TEXT,
ConPhylum TEXT,
ConSpecies TEXT)")
# Once the table is created, we can enter the data.
#INSERT specifies where the data is entered (here the School table).
#VALUES contains the data
dbSendQuery(conn = db,
"INSERT INTO Consumer
VALUES (1, 'Animalia', 'Arthropoda', 'Chaoborus trivittatus')")
dbSendQuery(conn = db,
"INSERT INTO Consumer
VALUES (2, 'Animalia', 'Arthropoda', 'Chaoborus americanus')")
dbSendQuery(conn = db,
"INSERT INTO Consumer
VALUES (3, 'Animalia', 'Chordata', 'Stizostedion vitreum')")
# Once we have our table, we can query the results using:
dbGetQuery(db, "SELECT * FROM Consumer")
dbGetQuery(db, "SELECT * FROM Consumer WHERE ConPhylum='Chordata'")
# Tables can be also imported from csv files.
# As example, let's use the Biotraits dataset.
# The easiest way is to read the csv files into R as data frames.
# Then the data frames are imported into the database.
Resource <- read.csv("../Data/Resource.csv")  # Read csv files into R
# Import data frames into database
dbWriteTable(conn = db, name = "Resource", value = Resource, row.names = FALSE)
# Check that the data have been correctly imported into the School table.
dbListTables(db)                 # The tables in the database
dbListFields(db,"Resource")       # The columns in a table
dbReadTable(db, "Resource")    # The data in a table
# Before leaving RSQLite, there is a bit of tidying-up to do.
# The connection to the database is closed, and as precaution
# the three data frames are removed from R’s environment.
dbDisconnect(db)            # Close connection
rm(list = c("Resource"))   # Remove data frames
df1 <- data.frame(c(1,2,3,4),c("A","B","C","D"))
names(df1) <- c("num","letter")
View(df1)
df1$num
b <- df1[1]
a <- df1$num
c <- df1['num']
d <- df1[['num']]
View(c)
typeof(a)
typeof(d)
typeof(b)
typeof(df1)
rm(list = ls())
### Load the RData file ###
load("../data/KeyWestAnnualMeanTemperature.RData")
plot(ats)
firstYear <- c()
secondYear <- c()
### pair the years ###
for(i in 1:(length(ats$Year)-1)){
firstYear <- append(firstYear,ats$Temp[i])
secondYear <- append(secondYear,ats$Temp[i+1])
}
correlationCoff <- cor(firstYear,secondYear)
tempVect <- ats$Temp
correlationCoffVector <- c()
### iterate for a significant amount of times ###
for (i in 1:10000){
tempVect <- sample(tempVect,length(ats$Year), replace = FALSE)
firstYear <- c()
secondYear <- c()
for(j in 1:(length(tempVect)-1)){
firstYear <- append(firstYear,tempVect[j])
secondYear <- append(secondYear,tempVect[j+1])
}
correlationCoffVector <- append(correlationCoffVector,cor(firstYear,secondYear))
}
### Compare the correlation coefficient ###
correlationCoffBoolean <- correlationCoffVector[correlationCoffVector>correlationCoff]
fractionCorrCoff <- length(correlationCoffBoolean) / 10000
print (fractionCorrCoff)
setwd("~/Documents/CMEEgroupwork5/code")
read.csv("../results/trees_TreeHts_R.csv")
install.packages("https://CRAN.R-project.org/package=pliman")
